Task 1a - 1f
I started task 1 by creating two public abstract classes Device and Satellite with public classes HandheldDevice, LaptopDevice and DesktopDevice that extend Device and StandardSatellite, TeleportingSatellite and RelaySatellite that extend Satellite. I added in parameters into both Desktop and Satellite constructors that are passed in through each type of Desktop/Satellite. I think I will have to add more parameters being passed in as I go through the next parts of the task such as range and speed. The design decisions I made today relate to single class responsibility and cohesion as device and satellite can handle methods related to their own types.

Task 1g
I created a new public class File so it can handle all file related operations, adhering to the single responsibility principle. In the File class I created getters for it's name, content and size of content. I did not create any setters as it would be unnecessary to allow re-setting of the name or content after it has been created thus adhering to encapsulation.

Task 1h
After doing this part of task 1 I got an idea to create an Entity public abstract class as well that Device and Satellite extend and have a inheritance "is-a" relationship with Entity as both classes share a lot of similar fields and methods. This would reduce repetition and simplify the design to be more maintainable through the abstraction and modularisation. The polymorphism in this also adheres to the Liskov Substitution Principle in which Device and Satellite can be treated as Entity objects when necessary which I think will help a lot in task 2.

Task 2a
While doing this part I utilised the design principle of pushing it to the right by creating an abstract method in Satellite called changePosition rather than creating the method inside BlackoutController. Since each different type of satellite has different behaviours in moving, I implemented it differently in each type's class. This shows use of inheritance in which an abstract method is overridden in Satellite's derived classes and specific behaviour is implented in these. I also had to add a lot of new parameters into Satellite's constructor so I am glad I made the decision earlier to have it as an abstract class so that it is easier to pass in different values for different types.

Task 2b
In this part I created two separate getInRangeForSatellites and getInRangeForDevices methods in Satellite and Device as they required different helpers to calculate whether the entities were in range or not. For example, Satellite can send files to both devices and satellites but Device can only send files to satellites. Once again this adheres to the single responsibility principle as each method has a clear, singular responsibility; one checks for satellites in range and the other checks for devices in range. This makes the code more maintainable and understandable. This also demonstrates encapsulation as the logic of the methods are encapsulated to their respective classes.

Task 2c
When I did this part initially I created methods called getFileToSend and sendFileToSat/sendFileToDevice in Satellite and Device but I was worried about high coupling as it would mean that I would have to call getFileToSend, use that file as a parameter in sendFileToSat/sendFileToDevice and then update various fields which felt like it was BlackoutController depending on functions in Satellite which depended on functions in File and I thought that might be a violation of Law of Demeter. This also violated single responsibility of the two Satellite and Device classes and added a lot of repetition.

I decided to instead create if statements inside sendFile in BlackoutController class that handled either if it was sending from a device or a satellite. I also created two methods called sendToSatellite and sendToDevice, thus not only reducing repetition but also ensuring single responsibility to each method. By removing the chains of methods with multiple objects I had before I now adhere to the Law of Demeter by encapsulating the behaviour within the BlackoutController and reducing the tightly coupled code from before.
I am still worried as I have a lot of if statements throwing certain exceptions and this might be repetitive, I will try to find a way to change this by looking for common exceptions thrown between the if statements and the two helper methods.

I had to change the isAllStorageUsed method to be overridden in the StandardSatellite class as I forgot to handle the case in which more than 3 files are stored in the Standard Satellite. Through this I utilised the inheritance that I had implemented before by modifying the behaviour of a method from the super class for a specific need of the subclass.

Reflection
I think overall I went okay but could have done better if I had managed my time better. I am a bit disappointed that I could not implement the specific behaviours of TeleportingSatellite and RelaySatellite in Task 2c but I also felt that if I did I would have messed up the design. I think this shows that my design is not perfect. This relates to the challenges I faced in terms of design. I had to decide a lot between whether I wanted to keep it tightly coupled and have classes that did not have single responsibility or have it loosely coupled with single responsibility classes and methods. I think in Tasks 2a-2b I decided to do the first option and in Task 2c I did the latter. I also had a hard time with figuring out how to implement the simulating the actual transferring of the file and I wasted a lot of time on that. Things I learned when completing these tasks include how good design is not just about having enough header comments, in-function comments, whitespace and good function/variable names but rather it is about making sure that it is maintainable, readable and extensible. By adhering to the OOP design principles I learned how to utilise polymorphism, abstraction, inheritance, encapsulation and modularisation to do so.